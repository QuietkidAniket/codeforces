{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

    "CP File header":
    {
        "prefix": "headercp",
        "body": [
        "/**",
        " *    author: Anicetus_7",
        " *    created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        "**/"
        ],
        "description": "Adds a Anicetus_7 style file header"
    },
    "boilerplate": 
    { 
        
    "prefix" : "boilerplate1", 
    "body" : [ 
        "/**",
        " *    author: Anicetus_7",
        " *    created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        "**/",
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "#define int long long",
        "#define INF (int)1e18",
        "#define MOD (int)(1e9 + 7)",
        "mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());",
        "",
        "void Solve(){",
        "\t",
        "\t",
        "}",
        "",
        "//|------------------------------------------[MAIN]------------------------------------------|",
        "int32_t main(){",
        "  auto begin = std::chrono::high_resolution_clock::now();",
        "  ios::sync_with_stdio(0); cin.tie(0);",
        "  int t = 1;",
        "  cin>> t;",
        "  for(int i = 1; i <= t; i++) ",
        "    {",
        "        //cerr << \"Case #\" << i << \": \";",
        "        Solve();",
        "    }",
        "  auto end = std::chrono::high_resolution_clock::now(); ",
        "  auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin); ",
        "  cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\"; ",
        "  return 0;",
        "}",
    ], 
    "description" : "Competitive Programming snippet for C++ code"
    },
    "leetcode": 
    { 
        "prefix" : "leetcode", 
                   "body" : [ 
                       "#include <bits/stdc++.h>",
                        "using namespace std;",
                        "", 
                        "void solve(){",
                        "\tSolution obj;",
                        "\tstring exp;",
                        "\twhile( (cin >> exp) )",
                        "\t",
                        "\tcout << '\\n';",
                        "}",
                       "int main()",
                       "{", 
                       "\tios::sync_with_stdio(0);",
                       "\tcin.tie(0);",
                       "\tcout.tie(0);",
                       "\tfreopen(\"$WORKSPACE_FOLDER/input.in\", \"r+\", stdin);",
                        "\tfreopen(\"$WORKSPACE_FOLDER/output.out\", \"w\", stdout);",
                       "\tsolve();",
                       "\t",
                       "\t",
                       "\treturn 0;", 
                       "}"
  
                   ], 
        "description" : "Competitive Programming snippet for C++ code"
    },
    "Disjoint Set":{
        "prefix": "DSU",
        "body": [
        "class DisjointSet{",
            "vector<int> parent, size;",
            "public:",
            "DisjointSet(int n){",
            "    parent.resize(n+1);",
            "    size.resize(n+1, 1);",
            "    // for 1 based indexing and 0 based indexing both",
            "    for(int i = 0 ;i <= n ;i++){",
            "        parent[i]= i;",
            "    }",
            "}",
            "",
            "int findUPar(int node){",
            "    if(node == parent[node])return node;",
            "    return parent[node] = findUPar(parent[node]);",
            "}",
            "",
            "void unionBySize(int u, int v){",
            "    int ulp_u = findUPar(u);",
            "    int ulp_v = findUPar(v);",
            "",
            "    if(ulp_u == ulp_v)return;",
            "    if(size[ulp_u] > size[ulp_v]){",
            "        parent[ulp_v] = ulp_u;",
            "        size[ulp_u] += size[ulp_v];",
            "    }else{",
            "        parent[ulp_u] = ulp_v;",
            "        size[ulp_v] += size[ulp_u];",
            "    }",
            "}",
        "};"
        ],
        "description": "to produce the snippet for Disjoint Set Union (DSU)"
    },
    "tree":{
        "prefix": "tree",
        "body": [
"struct Tree {",
"    vector<vector<int>> adj, lift;    ",
"    vector<int> d, tin, tout, par;",
"    int n, timer;",
"    bool initialized = false;",
"    bool dfsed = false;",
" ",
"    void init(int nn){",
"        n = nn;",
"        adj.resize(n + 1);",
"        d.resize(n + 1);",
"        lift.resize(n + 1);",
"        tin.resize(n + 1);",
"        tout.resize(n + 1);",
"        par.resize(n + 1);",
"        for (int i = 1; i <= n; i++) adj[i].clear();",
"        for (int i = 0; i <= n; i++) lift[i].resize(20, 0);",
"        initialized = true;",
"    }",
" ",
"    void addEdge(int u, int v){",
"        if (!initialized){",
"            cout << \"STUPID INITIALIZE\\n\";",
"            exit(0);",
"        }",
"        adj[u].push_back(v);",
"        adj[v].push_back(u);",
"    }",
" ",
"    void build(){",
"        for (int j = 1; j < 20; j++){",
"            for (int i = 1; i <= n; i++){",
"                lift[i][j] = lift[lift[i][j - 1]][j - 1];",
"            }",
"        }",
"    }",
" ",
"    void dfs(int u, int par1){",
"        par[u] = par1;",
"        tin[u] = ++timer;",
"        for (int v : adj[u]){",
"            if (v != par1){",
"                d[v] = d[u] + 1;",
"                lift[v][0] = u;",
"                dfs(v, u);",
"            }",
"        }",
"        tout[u] = timer;",
"    }",
" ",
"    void dfs(int root = 1){",
"        if (!initialized){",
"            cout << \"STUPID INITIALIZE\\n\";",
"            exit(0);",
"        }",
"        d[root] = 0;",
"        timer = 0;",
"        dfs(root, 0);",
"        build();",
"        dfsed = true;",
"    }",
" ",
"    int jump(int x, int depth){",
"        for (int i = 0; i < 20; i++) if (depth >> i & 1){",
"            x = lift[x][i];",
"        }",
"        return x;",
"    }",
" ",
"    int lca(int a, int b){",
"        if (!dfsed){",
"            cout << \"STUPID DFS\\n\";",
"            exit(0);",
"        }",
"        if (d[a] < d[b]) swap(a, b);",
"        int del = d[a] - d[b];",
"        for (int i = 0; i < 20; i++) if (del >> i & 1) a = lift[a][i];",
" ",
"        if (a == b) return a;",
" ",
"        for (int i = 19; i >= 0; i--) if (lift[a][i] != lift[b][i]){",
"            a = lift[a][i];",
"            b = lift[b][i];",
"        }",
"        return lift[a][0];",
"    }",
" ",
"    int dist(int a, int b){",
"        return d[a] + d[b] - 2 * d[lca(a, b)];",
"    }",
" ",
"    bool anc(int x, int y){",
"        return tin[x] <= tin[y] && tout[x] >= tout[y];",
"    }",
"};"
    ]
    },
    "range sum segment tree":{
        "prefix" : "range sum segment tree",
        "body": [
            "struct segtree{",
                "\tvector<int>tree;",
                "\tint sz;",
                "\tvoid init(int n){",
                    "\t\tsz=1;",
                    "\t\tsz<<= log2(n)+1;",
                    "\t\ttree.assign(sz*2-1,0);",
                "\t}",
                "\tvoid set(int x,int lx,int rx,int i,int v){",
                    "\t\tif(rx-lx==1){tree[x]+=v;return;}",
                    "\t\tint m=(lx+rx)/2;",
                    "\t\tif(i<m)set(x*2+1,lx,m,i,v);",
                    "\t\telse set(x*2+2,m,rx,i,v);",
                    "\t\ttree[x]=tree[x*2+1]+tree[x*2+2];",
                "\t}",
                "\tvoid set(int i,int v){",
                    "\t\tset(0,0,sz,i,v);",
                "\t}",
                "\tint get(int x,int lx,int rx,int l,int r){",
                    "\t\tif(r<=lx || rx<=l)return 0;",
                    "\t\tif(l<=lx && r>=rx)return tree[x];",
                    "\t\tint m=(lx+rx)/2;",
                    "\t\treturn get(x*2+1,lx,m,l,r)+get(x*2+2,m,rx,l,r);",
                "\t}",
                "\tint get(int l,int r){",
                    "\t\treturn get(0,0,sz,l,r);",
                "\t}",
            "};"
        ]

    },
    "Sparse table":{
        "prefix": "sparsetable",
        "body": [
"struct SparseTable{",
"    int n, l;",
"    vector<vector<int>> sp;",
" ",
"    inline int combine(int x, int y){",
"        return gcd(x, y);",
"        // fill this in",
"    }",
" ",
"    inline void init(int nn, vector <int> v){",
"        n = nn;",
"        if (v.size() == n){",
"            vector <int> v2;",
"            v2.push_back(0);",
"            for (auto x : v) v2.push_back(x);",
"            v = v2;",
"        }",
" ",
"        l = 0;",
"        while ((1 << l) <= n){",
"            l++;",
"        }",
"        sp = vector<vector<int>>(l, vector<int>(n + 1));",
" ",
"        for (int i = 1; i <= n; i++){",
"            sp[0][i] = v[i];",
"        }",
" ",
"        for (int j = 1; j < l; j++){",
"            for (int i = 1; i <= n; i++){",
"                int who = i + (1 << (j - 1));",
"                if (who <= n)",
"                sp[j][i] = combine(sp[j - 1][i], sp[j - 1][who]);",
"            }",
"        }",
"    }",
" ",
"    inline int query(int l, int r){",
"        int i = log2(r - l + 1);",
"        // cout << \"QUERYING \" << l << \" \" << r << \" \";",
"        // cout << i << \"\\n\";",
"        // cout << sp[i][l] << \" \" << sp[i][r + 1 - (1 << i)] << \"\\n\";",
"        int v = combine(sp[i][l], sp[i][r + 1 - (1 << i)]);",
"        return v;",
"    }",
"};"
        ]
    },

    "power": 
    {
    "prefix" : "power",
        "body" : [
            "int modPow(int base, int exp) {",
                "\tint res = 1;",
                "\twhile (exp > 0) {",
                "\t    if (exp & 1ll) res = (res * base) % MOD;",
                "\t    base = (base * base) % MOD;",
                "\t    exp >>= 1ll;",
                "\t}",
                "\treturn res;",
                "}"
            ],
            "description": "to produce snippet for power code compatible with mod"
    },
    "input": 
    {
    "prefix" : "ci",
        "body" : [
                "cin >> ",
            ],
            "description": "to produce the snippet for cin >> "
    },
    "output": 
    {
    "prefix" : "co",
        "body" : [
            "cout << ",
            ],
            "description": "to produce the snippet for cout << "
    },
    
    "for loop": 
    {
    "prefix" : "fi",
        "body" : [
            "for(int i = 0; i< n; i++)",
            "{",
            "\t",
            "}",
            ],
            "description": "to produce the snippet for for loop"
    },

    "for loop with variable j": 
    {
    "prefix" : "fj",
        "body" : [
            "for(int j = 0; j< n; j++)",
            "{",
            "\t",
            "}",
            ],
            "description": "to produce the snippet for for loop"
    },

    "input loop": 
    {
    "prefix" : "li",
        "body" : [
            "for(int i = 0; i< n; i++)",
            "{",
            "\tcin >> arr[i];",
            "}",
            ],
            "description": "to produce the snippet for input loop"
    },
    "display loop": 
    {
    "prefix" : "di",
        "body" : [
            "for(int i = 0; i< n; i++)",
            "{",
            "\tcout << arr[i] << \", \"; ",
            "}",
            "cout << '\\n';",
            ],
            "description": "to produce the snippet for display loop"
    },
    "for each loop": 
    {
    "prefix" : "efi",
        "body" : [
            "for(const auto& x : arr)",
            "{",
            "\t",
            "}",
            ],
            "description": "to produce the snippet for for-each loop"
    },
   "Debug Template": {
  "prefix": "debugtemplate",
  "body": [
    "template <typename A, typename B>",
    "string to_string(pair<A, B> p);",
    "",
    "template <typename A, typename B, typename C>",
    "string to_string(tuple<A, B, C> p);",
    "",
    "template <typename A, typename B, typename C, typename D>",
    "string to_string(tuple<A, B, C, D> p);",
    "",
    "string to_string(const string& s) {",
    "  return '\"' + s + '\"';",
    "}",
    "",
    "string to_string(const char* s) {",
    "  return to_string((string) s);",
    "}",
    "",
    "string to_string(bool b) {",
    "  return (b ? \"true\" : \"false\");",
    "}",
    "",
    "string to_string(vector<bool> v) {",
    "  bool first = true;",
    "  string res = \"{\";",
    "  for (int i = 0; i < static_cast<int>(v.size()); i++) {",
    "    if (!first) {",
    "      res += \", \";",
    "    }",
    "    first = false;",
    "    res += to_string(v[i]);",
    "  }",
    "  res += \"}\";",
    "  return res;",
    "}",
    "",
    "template <size_t N>",
    "string to_string(bitset<N> v) {",
    "  string res = \"\";",
    "  for (size_t i = 0; i < N; i++) {",
    "    res += static_cast<char>('0' + v[i]);",
    "  }",
    "  return res;",
    "}",
    "",
    "template <typename A>",
    "string to_string(A v) {",
    "  bool first = true;",
    "  string res = \"{\";",
    "  for (const auto &x : v) {",
    "    if (!first) {",
    "      res += \", \";",
    "    }",
    "    first = false;",
    "    res += to_string(x);",
    "  }",
    "  res += \"}\";",
    "  return res;",
    "}",
    "",
    "template <typename A, typename B>",
    "string to_string(pair<A, B> p) {",
    "  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
    "}",
    "",
    "template <typename A, typename B, typename C>",
    "string to_string(tuple<A, B, C> p) {",
    "  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";",
    "}",
    "",
    "template <typename A, typename B, typename C, typename D>",
    "string to_string(tuple<A, B, C, D> p) {",
    "  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";",
    "}",
    "",
    "void debug_out() { cerr << endl; }",
    "",
    "template <typename Head, typename... Tail>",
    "void debug_out(Head H, Tail... T) {",
    "  cerr << \" \" << to_string(H);",
    "  debug_out(T...);",
    "}",
    "",
    "#ifdef ONLINE_JUDGE",
    "#define debug(...) 42",
    "#else",
    "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
    "#endif"
  ],
  "description": "C++ debug template with to_string and debug macros"
}

}