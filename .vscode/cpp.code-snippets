{
    "CP File header":
    {
        "prefix": "headercp",
        "body": [
        "/**",
        " *    author: Anicetus_7",
        " *    created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        "**/"
        ],
        "description": "Adds a Anicetus_7 style file header"
    },
    "boilerplate":
    {

    "prefix" : "boilerplate1",
    "body" : [
        "/**",
        " *    author: Anicetus_7",
        " *    created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        "**/",
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "#define int long long",
        "#define INF (int)1e18",
        "#define MOD (int)(1e9 + 7)",
        "#define MAX (int)(200005)",
        "mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());",
        "",
        "void Solve(){",
        "\t$0",
        "\t",
        "}",
        "",
        "//|------------------------------------------[MAIN]------------------------------------------|",
        "int32_t main(){",
        "  auto begin = std::chrono::high_resolution_clock::now();",
        "  ios::sync_with_stdio(0); cin.tie(0);",
        "  int t = 1;",
        "  cin>> t;",
        "  for(int i = 1; i <= t; i++) ",
        "    {",
        "        //cout << \"Case #\" << i << \": \\n\";",
        "        Solve();",
        "    }",
        "  auto end = std::chrono::high_resolution_clock::now(); ",
        "  auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin); ",
        "  cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\"; ",
        "  return 0;",
        "}",
    ],
    "description" : "Competitive Programming snippet for C++ code"
    },
    "leetcode":
    {
        "prefix" : "leetcode",
                   "body" : [
                       "#include <bits/stdc++.h>",
                        "using namespace std;",
                        "",
                        "void solve(){",
                        "\tSolution obj;",
                        "\tstring exp;",
                        "\twhile( (cin >> exp) )",
                        "\t",
                        "\tcout << '\\n';",
                        "}",
                       "int main()",
                       "{",
                       "\tios::sync_with_stdio(0);",
                       "\tcin.tie(0);",
                       "\tcout.tie(0);",
                       "\tfreopen(\"$WORKSPACE_FOLDER/input.in\", \"r+\", stdin);",
                        "\tfreopen(\"$WORKSPACE_FOLDER/output.out\", \"w\", stdout);",
                       "\tsolve();",
                       "\t",
                       "\t",
                       "\treturn 0;",
                       "}"

                   ],
        "description" : "Competitive Programming snippet for C++ code"
    },
    "Disjoint Set":{
        "prefix": "disjoint_set",
        "body": [
        "class DisjointSet{",
        "public:",
        "    vector<int> parents;",
        "    vector<int> sizes;",
        "    DisjointSet(int size) : parents(size), sizes(size, 1) {",
        "        for (int i = 0; i < size; i++) { parents[i] = i; }",
        "    }",
        " ",
        "    /** @return the \"representative\" node in x's component */",
        "    int find(int x) {",
        "        return parents[x] == x ? x : (parents[x] = find(parents[x]));",
        "    }",
        " ",
        "    /** @return whether the merge changed connectivity */",
        "    bool unite(int x, int y) {",
        "        int x_root = find(x);",
        "        int y_root = find(y);",
        "        if (x_root == y_root) { return false; }",
        " ",
        "        if (sizes[x_root] < sizes[y_root]) { swap(x_root, y_root); }",
        "        sizes[x_root] += sizes[y_root];",
        "        parents[y_root] = x_root;",
        "        return true;",
        "    }",
        " ",
        "    /** @return whether x and y are in the same connected component */",
        "    bool connected(int x, int y) { return find(x) == find(y); }",
        "};",

        ],
        "description": "to produce the snippet for Disjoint Set Union (DSU)"
    },
  "Tree LCA Struct": {
    "prefix": "tree_lca",
    "body": [
      "struct Tree {",
      "    vector<vector<int>> adj, lift;",
      "    vector<int> d, tin, tout, par;",
      "    int n, timer;",
      "    bool initialized = false;",
      "    bool dfsed = false;",
      "",
      "    /**",
      "     * @brief Initialize tree data structures",
      "     * @param nn number of nodes",
      "     */",
      "    void init(int nn){",
      "        n = nn;",
      "        adj.resize(n + 1);",
      "        d.resize(n + 1);",
      "        lift.resize(n + 1);",
      "        tin.resize(n + 1);",
      "        tout.resize(n + 1);",
      "        par.resize(n + 1);",
      "        for (int i = 1; i <= n; i++) adj[i].clear();",
      "        for (int i = 0; i <= n; i++) lift[i].resize(20, 0);",
      "        initialized = true;",
      "    }",
      "",
      "    /**",
      "     * @brief Add undirected edge between u and v",
      "     */",
      "    void addEdge(int u, int v){",
      "        if (!initialized){",
      "            cout << \"STUPID INITIALIZE\\\\n\";",
      "            exit(0);",
      "        }",
      "        adj[u].push_back(v);",
      "        adj[v].push_back(u);",
      "    }",
      "",
      "    /**",
      "     * @brief Build binary lifting table (2^j ancestors)",
      "     */",
      "    void build(){",
      "        for (int j = 1; j < 20; j++){",
      "            for (int i = 1; i <= n; i++){",
      "                lift[i][j] = lift[lift[i][j - 1]][j - 1];",
      "            }",
      "        }",
      "    }",
      "",
      "    /**",
      "     * @brief DFS traversal to compute depths, parents, entry/exit times",
      "     * @param u current node",
      "     * @param par1 parent of current node",
      "     */",
      "    void dfs(int u, int par1){",
      "        par[u] = par1;",
      "        tin[u] = ++timer;",
      "        for (int v : adj[u]){",
      "            if (v != par1){",
      "                d[v] = d[u] + 1;",
      "                lift[v][0] = u;",
      "                dfs(v, u);",
      "            }",
      "        }",
      "        tout[u] = timer;",
      "    }",
      "",
      "    /**",
      "     * @brief Wrapper DFS from root, also builds binary lifting table",
      "     * @param root root of the tree (default = 1)",
      "     */",
      "    void dfs(int root = 1){",
      "        if (!initialized){",
      "            cout << \"STUPID INITIALIZE\\\\n\";",
      "            exit(0);",
      "        }",
      "        d[root] = 0;",
      "        timer = 0;",
      "        dfs(root, 0);",
      "        build();",
      "        dfsed = true;",
      "    }",
      "",
      "    /**",
      "     * @brief Jump up by given depth using binary lifting",
      "     * @return ancestor of node x after climbing 'depth' levels",
      "     */",
      "    int jump(int x, int depth){",
      "        for (int i = 0; i < 20; i++) if (depth >> i & 1){",
      "            x = lift[x][i];",
      "        }",
      "        return x;",
      "    }",
      "",
      "    /**",
      "     * @brief Compute Lowest Common Ancestor (LCA) of two nodes",
      "     * @return LCA of nodes a and b",
      "     */",
      "    int lca(int a, int b){",
      "        if (!dfsed){",
      "            cout << \"STUPID DFS\\\\n\";",
      "            exit(0);",
      "        }",
      "        if (d[a] < d[b]) swap(a, b);",
      "        int del = d[a] - d[b];",
      "        for (int i = 0; i < 20; i++) if (del >> i & 1) a = lift[a][i];",
      "",
      "        if (a == b) return a;",
      "",
      "        for (int i = 19; i >= 0; i--) if (lift[a][i] != lift[b][i]){",
      "            a = lift[a][i];",
      "            b = lift[b][i];",
      "        }",
      "        return lift[a][0];",
      "    }",
      "",
      "    /**",
      "     * @brief Compute distance between two nodes",
      "     * @return number of edges in path between a and b",
      "     */",
      "    int dist(int a, int b){",
      "        return d[a] + d[b] - 2 * d[lca(a, b)];",
      "    }",
      "",
      "    /**",
      "     * @brief Check if x is ancestor of y",
      "     * @return true if x is ancestor of y",
      "     */",
      "    bool anc(int x, int y){",
      "        return tin[x] <= tin[y] && tout[x] >= tout[y];",
      "    }",
      "};"
    ],
    "description": "Tree struct with LCA, distance, ancestor checks (binary lifting)"
  },
  "Graph Template":{
    "scope": "cpp",
    "prefix": "Graph template",
    "body": [
        "template <typename T>",
        "class graph {",
        " public:",
        "  struct edge {",
        "    int from;",
        "    int to;",
        "    T cost;",
        "  };",
        " ",
        "  vector<edge> edges;",
        "  vector<vector<int>> g;",
        "  int n;",
        " ",
        "  graph(int _n) : n(_n) {",
        "    g.resize(n);",
        "  }",
        " ",
        "  virtual int add(int from, int to, T cost) = 0;",
        "};",
        " ",
        "template <typename T>",
        "class forest : public graph<T> {",
        " public:",
        "  using graph<T>::edges;",
        "  using graph<T>::g;",
        "  using graph<T>::n;",
        " ",
        "  forest(int _n) : graph<T>(_n) {",
        "  }",
        " ",
        "  int add(int from, int to, T cost = 1) {",
        "    assert(0 <= from && from < n && 0 <= to && to < n);",
        "    int id = (int) edges.size();",
        "    assert(id < n - 1);",
        "    g[from].push_back(id);",
        "    g[to].push_back(id);",
        "    edges.push_back({from, to, cost});",
        "    return id;",
        "  }",
        "};",
        " ",
        "template <typename T>",
        "class dfs_forest : public forest<T> {",
        " public:",
        "  using forest<T>::edges;",
        "  using forest<T>::g;",
        "  using forest<T>::n;",
        " ",
        "  vector<int> pv;",
        "  vector<int> pe;",
        "  vector<int> order;",
        "  vector<int> pos;",
        "  vector<int> end;",
        "  vector<int> sz;",
        "  vector<int> root;",
        "  vector<int> depth;",
        "  vector<T> dist;",
        " ",
        "  dfs_forest(int _n) : forest<T>(_n) {",
        "  }",
        " ",
        "  void init() {",
        "    pv = vector<int>(n, -1);",
        "    pe = vector<int>(n, -1);",
        "    order.clear();",
        "    pos = vector<int>(n, -1);",
        "    end = vector<int>(n, -1);",
        "    sz = vector<int>(n, 0);",
        "    root = vector<int>(n, -1);",
        "    depth = vector<int>(n, -1);",
        "    dist = vector<T>(n);",
        "  }",
        " ",
        "  void clear() {",
        "    pv.clear();",
        "    pe.clear();",
        "    order.clear();",
        "    pos.clear();",
        "    end.clear();",
        "    sz.clear();",
        "    root.clear();",
        "    depth.clear();",
        "    dist.clear();",
        "  }",
        " ",
        " private:",
        "  void do_dfs(int v) {",
        "    pos[v] = (int) order.size();",
        "    order.push_back(v);",
        "    sz[v] = 1;",
        "    for (int id : g[v]) {",
        "      if (id == pe[v]) {",
        "        continue;",
        "      }",
        "      auto &e = edges[id];",
        "      int to = e.from ^ e.to ^ v;",
        "      depth[to] = depth[v] + 1;",
        "      dist[to] = dist[v] + e.cost;",
        "      pv[to] = v;",
        "      pe[to] = id;",
        "      root[to] = (root[v] != -1 ? root[v] : to);",
        "      do_dfs(to);",
        "      sz[v] += sz[to];",
        "    }",
        "    end[v] = (int) order.size() - 1;",
        "  }",
        " ",
        "  void do_dfs_from(int v) {",
        "    depth[v] = 0;",
        "    dist[v] = T{};",
        "    root[v] = v;",
        "    pv[v] = pe[v] = -1;",
        "    do_dfs(v);",
        "  }",
        " ",
        " public:",
        "  void dfs(int v, bool clear_order = true) {",
        "    if (pv.empty()) {",
        "      init();",
        "    } else {",
        "      if (clear_order) {",
        "        order.clear();",
        "      }",
        "    }",
        "    do_dfs_from(v);",
        "  }",
        " ",
        "  void dfs_all() {",
        "    init();",
        "    for (int v = 0; v < n; v++) {",
        "      if (depth[v] == -1) {",
        "        do_dfs_from(v);",
        "      }",
        "    }",
        "    assert((int) order.size() == n);",
        "  }",
        "};"
    ],
    "description": "Template for graph and forest",
  },
	"SegTree Min/Max Lazy": {
	"prefix": "sgtmin",
	"body": [
		"struct SegTree {",
		"    int n;",
		"    vector<int> seg, lazy;",
		"    // [SWITCH] For MAX: change INF to -INF, min to max",
		"    const int NEUTRAL = INF;",
		"",
		"    SegTree(int _n) {",
		"        n = _n;",
		"        seg.assign(4 * n + 5, NEUTRAL);",
		"        lazy.assign(4 * n + 5, 0);",
		"    }",
		"",
		"    void push(int l, int r, int pos) {",
		"        if (lazy[pos] == 0) return;",
		"        seg[pos] += lazy[pos];",
		"        if (l != r) {",
		"            lazy[pos * 2] += lazy[pos];",
		"            lazy[pos * 2 + 1] += lazy[pos];",
		"        }",
		"        lazy[pos] = 0;",
		"    }",
		"",
		"    void build(const vector<int>& a, int l, int r, int pos) {",
		"        if (l == r) {",
		"            seg[pos] = a[l - 1];",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        build(a, l, mid, pos * 2);",
		"        build(a, mid + 1, r, pos * 2 + 1);",
		"        // [SWITCH] Change min to max here",
		"        seg[pos] = min(seg[pos * 2], seg[pos * 2 + 1]);",
		"    }",
		"",
		"    void update(int l, int r, int pos, int ql, int qr, int qval) {",
		"        push(l, r, pos);",
		"        if (ql > r || qr < l) return;",
		"        if (ql <= l && qr >= r) {",
		"            lazy[pos] += qval;",
		"            push(l, r, pos);",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        update(l, mid, pos * 2, ql, qr, qval);",
		"        update(mid + 1, r, pos * 2 + 1, ql, qr, qval);",
		"        // [SWITCH] Change min to max here",
		"        seg[pos] = min(seg[pos * 2], seg[pos * 2 + 1]);",
		"    }",
		"",
		"    int query(int l, int r, int pos, int ql, int qr) {",
		"        push(l, r, pos);",
		"        if (ql > r || qr < l) return NEUTRAL;",
		"        if (ql <= l && qr >= r) return seg[pos];",
		"        int mid = (l + r) / 2;",
		"        // [SWITCH] Change min to max here",
		"        return min(query(l, mid, pos * 2, ql, qr), query(mid + 1, r, pos * 2 + 1, ql, qr));",
		"    }",
		"",
		"    void build(const vector<int>& a) { build(a, 1, n, 1); }",
		"    void update(int ql, int qr, int val) { update(1, n, 1, ql, qr, val); }",
		"    int query(int ql, int qr) { return query(1, n, 1, ql, qr); }",
		"};"
	],
	"description": "Segment Tree for Range Minimum/Maximum Query with Lazy Propagation (Range Add)"
    },
	"SegTree Sum Lazy": {
	"prefix": "sgtsum",
	"body": [
		"struct SegTree {",
		"    int n;",
		"    vector<int> seg;",
		"    vector<int> lazy;",
		"",
		"    SegTree(int _n) {",
		"        n = _n;",
		"        seg.assign(4 * n + 5, 0);",
		"        lazy.assign(4 * n + 5, 0);",
		"    }",
		"",
		"    void push(int l, int r, int pos) {",
		"        if (lazy[pos] == 0) return;",
		"        seg[pos] += lazy[pos] * (r - l + 1);",
		"        if (l != r) {",
		"            lazy[pos * 2] += lazy[pos];",
		"            lazy[pos * 2 + 1] += lazy[pos];",
		"        }",
		"        lazy[pos] = 0;",
		"    }",
		"",
		"    void build(const vector<int>& a, int l, int r, int pos) {",
		"        if (l == r) {",
		"            seg[pos] = a[l - 1];",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        build(a, l, mid, pos * 2);",
		"        build(a, mid + 1, r, pos * 2 + 1);",
		"        seg[pos] = seg[pos * 2] + seg[pos * 2 + 1];",
		"    }",
		"",
		"    void update(int l, int r, int pos, int ql, int qr, int qval) {",
		"        push(l, r, pos);",
		"        if (ql > r || qr < l) return;",
		"        if (ql <= l && qr >= r) {",
		"            lazy[pos] += qval;",
		"            push(l, r, pos);",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        update(l, mid, pos * 2, ql, qr, qval);",
		"        update(mid + 1, r, pos * 2 + 1, ql, qr, qval);",
		"        seg[pos] = seg[pos * 2] + seg[pos * 2 + 1];",
		"    }",
		"",
		"    int query(int l, int r, int pos, int ql, int qr) {",
		"        push(l, r, pos);",
		"        if (ql > r || qr < l) return 0;",
		"        if (ql <= l && qr >= r) return seg[pos];",
		"        int mid = (l + r) / 2;",
		"        return query(l, mid, pos * 2, ql, qr) + query(mid + 1, r, pos * 2 + 1, ql, qr);",
		"    }",
		"",
		"    void build(const vector<int>& a) { build(a, 1, n, 1); }",
		"    void update(int ql, int qr, int val) { update(1, n, 1, ql, qr, val); }",
		"    int query(int ql, int qr) { return query(1, n, 1, ql, qr); }",
		"};"
	],
	"description": "Segment Tree for Range Sum Query with Lazy Propagation (Range Add)"
    },
	"SegTree GCD": {
	"prefix": "sgtgcd",
	"body": [
		"struct SegTree {",
		"    int n;",
		"    vector<int> seg;",
		"",
		"    SegTree(int _n) {",
		"        n = _n;",
		"        seg.assign(4 * n + 5, 0);",
		"    }",
		"",
		"    int gcd(int a, int b) {",
		"        if (b == 0) return a;",
		"        return gcd(b, a % b);",
		"    }",
		"",
		"    void build(const vector<int>& a, int l, int r, int pos) {",
		"        if (l == r) {",
		"            seg[pos] = a[l - 1];",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        build(a, l, mid, pos * 2);",
		"        build(a, mid + 1, r, pos * 2 + 1);",
		"        seg[pos] = gcd(seg[pos * 2], seg[pos * 2 + 1]);",
		"    }",
		"",
		"    void update(int l, int r, int pos, int idx, int val) {",
		"        if (l == r) {",
		"            seg[pos] = val;",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        if (idx <= mid) update(l, mid, pos * 2, idx, val);",
		"        else update(mid + 1, r, pos * 2 + 1, idx, val);",
		"        seg[pos] = gcd(seg[pos * 2], seg[pos * 2 + 1]);",
		"    }",
		"",
		"    int query(int l, int r, int pos, int ql, int qr) {",
		"        if (ql > r || qr < l) return 0; // 0 is identity for GCD",
		"        if (ql <= l && qr >= r) return seg[pos];",
		"        int mid = (l + r) / 2;",
		"        return gcd(query(l, mid, pos * 2, ql, qr), query(mid + 1, r, pos * 2 + 1, ql, qr));",
		"    }",
		"",
		"    void build(const vector<int>& a) { build(a, 1, n, 1); }",
		"    void update(int idx, int val) { update(1, n, 1, idx, val); }",
		"    int query(int ql, int qr) { return query(1, n, 1, ql, qr); }",
		"};"
	],
	"description": "Segment Tree for Range GCD Query with Point Update"
    },
	"SegTree Frequency": {
	"prefix": "sgtfreq",
	"body": [
		"struct Node {",
		"    int val;",
		"    int cnt;",
		"};",
		"",
		"struct SegTree {",
		"    int n;",
		"    vector<Node> seg;",
		"    vector<int> lazy;",
		"    const int INF_VAL = 1e18;",
		"",
		"    SegTree(int _n) {",
		"        n = _n;",
		"        seg.resize(4 * n + 5);",
		"        lazy.assign(4 * n + 5, 0);",
		"    }",
		"",
		"    Node merge(Node a, Node b) {",
		"        if (a.val < b.val) return a;",
		"        if (b.val < a.val) return b;",
		"        return {a.val, a.cnt + b.cnt};",
		"    }",
		"",
		"    void push(int l, int r, int pos) {",
		"        if (lazy[pos] == 0) return;",
		"        seg[pos].val += lazy[pos];",
		"        if (l != r) {",
		"            lazy[pos * 2] += lazy[pos];",
		"            lazy[pos * 2 + 1] += lazy[pos];",
		"        }",
		"        lazy[pos] = 0;",
		"    }",
		"",
		"    void build(const vector<int>& a, int l, int r, int pos) {",
		"        if (l == r) {",
		"            seg[pos] = {a[l - 1], 1};",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        build(a, l, mid, pos * 2);",
		"        build(a, mid + 1, r, pos * 2 + 1);",
		"        seg[pos] = merge(seg[pos * 2], seg[pos * 2 + 1]);",
		"    }",
		"",
		"    void update(int l, int r, int pos, int ql, int qr, int qval) {",
		"        push(l, r, pos);",
		"        if (ql > r || qr < l) return;",
		"        if (ql <= l && qr >= r) {",
		"            lazy[pos] += qval;",
		"            push(l, r, pos);",
		"            return;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        update(l, mid, pos * 2, ql, qr, qval);",
		"        update(mid + 1, r, pos * 2 + 1, ql, qr, qval);",
		"        seg[pos] = merge(seg[pos * 2], seg[pos * 2 + 1]);",
		"    }",
		"",
		"    Node query(int l, int r, int pos, int ql, int qr) {",
		"        push(l, r, pos);",
		"        if (ql > r || qr < l) return {INF_VAL, 0};",
		"        if (ql <= l && qr >= r) return seg[pos];",
		"        int mid = (l + r) / 2;",
		"        return merge(query(l, mid, pos * 2, ql, qr), query(mid + 1, r, pos * 2 + 1, ql, qr));",
		"    }",
		"",
		"    void build(const vector<int>& a) { build(a, 1, n, 1); }",
		"    void update(int ql, int qr, int val) { update(1, n, 1, ql, qr, val); }",
		"    Node query(int ql, int qr) { return query(1, n, 1, ql, qr); }",
		"};"
	],
	"description": "Segment Tree for Range Min Value AND Count of Min Value"
    },
    "Sparse table":{
        "prefix": "sparsetable",
        "body": [
"struct SparseTable{",
"    int n, l;",
"    vector<vector<int>> sp;",
" ",
"    inline int combine(int x, int y){",
"        return gcd(x, y);",
"        // fill this in",
"    }",
" ",
"    inline void init(int nn, vector <int> v){",
"        n = nn;",
"        if (v.size() == n){",
"            vector <int> v2;",
"            v2.push_back(0);",
"            for (auto x : v) v2.push_back(x);",
"            v = v2;",
"        }",
" ",
"        l = 0;",
"        while ((1 << l) <= n){",
"            l++;",
"        }",
"        sp = vector<vector<int>>(l, vector<int>(n + 1));",
" ",
"        for (int i = 1; i <= n; i++){",
"            sp[0][i] = v[i];",
"        }",
" ",
"        for (int j = 1; j < l; j++){",
"            for (int i = 1; i <= n; i++){",
"                int who = i + (1 << (j - 1));",
"                if (who <= n)",
"                sp[j][i] = combine(sp[j - 1][i], sp[j - 1][who]);",
"            }",
"        }",
"    }",
" ",
"    inline int query(int l, int r){",
"        int i = log2(r - l + 1);",
"        // cout << \"QUERYING \" << l << \" \" << r << \" \";",
"        // cout << i << \"\\n\";",
"        // cout << sp[i][l] << \" \" << sp[i][r + 1 - (1 << i)] << \"\\n\";",
"        int v = combine(sp[i][l], sp[i][r + 1 - (1 << i)]);",
"        return v;",
"    }",
"};"
        ]
    },
    "Treap (Cartesian Tree)": {
	"prefix": "treap",
	"body": [
		"struct Treap {",
		"    struct Node {",
		"        int val, prior, sz;",
		"        Node *l, *r;",
		"        Node(int v) : val(v), prior(RNG()), sz(1), l(NULL), r(NULL) {}",
		"    };",
		"",
		"    Node* root = NULL;",
		"",
		"    int sz(Node* t) { return t ? t->sz : 0; }",
		"",
		"    void upd(Node* t) {",
		"        if (t) t->sz = 1 + sz(t->l) + sz(t->r);",
		"    }",
		"",
		"    // Split: l has keys <= key, r has keys > key",
		"    void split(Node* t, int key, Node*& l, Node*& r) {",
		"        if (!t) l = r = NULL;",
		"        else if (t->val <= key) split(t->r, key, t->r, r), l = t;",
		"        else split(t->l, key, l, t->l), r = t;",
		"        upd(t);",
		"    }",
		"",
		"    // Merge: l keys must be <= r keys",
		"    void merge(Node*& t, Node* l, Node* r) {",
		"        if (!l || !r) t = l ? l : r;",
		"        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;",
		"        else merge(r->l, l, r->l), t = r;",
		"        upd(t);",
		"    }",
		"",
		"    // Insert value",
		"    void insert(int val) {",
		"        Node *l, *r;",
		"        split(root, val, l, r);",
		"        merge(root, l, new Node(val));",
		"        merge(root, root, r);",
		"    }",
		"",
		"    // Erase ALL occurrences of value",
		"    void erase(int val) {",
		"        Node *l, *r, *mid;",
		"        split(root, val - 1, l, r);",
		"        split(r, val, mid, r);",
		"        // delete mid; // optional memory cleanup",
		"        merge(root, l, r);",
		"    }",
		"",
		"    // Union: Merges another treap (other_root) into this one.",
		"    // Destructive: other_root is consumed.",
		"    void unite(Node*& t, Node* other) {",
		"        if (!t || !other) { t = t ? t : other; return; }",
		"        if (t->prior < other->prior) swap(t, other);",
		"        Node *lt, *rt;",
		"        split(other, t->val, lt, rt);",
		"        unite(t->l, lt);",
		"        unite(t->r, rt);",
		"        upd(t);",
		"    }",
		"    void unite(Treap& other) { unite(root, other.root); other.root = NULL; }",
		"",
		"    // Build from vector",
		"    void build(const vector<int>& v) {",
		"        for (int x : v) insert(x);",
		"    }",
		"",
		"    // Get k-th smallest (1-based)",
		"    int kth(Node* t, int k) {",
		"        int cnt = sz(t->l) + 1;",
		"        if (cnt == k) return t->val;",
		"        if (cnt > k) return kth(t->l, k);",
		"        return kth(t->r, k - cnt);",
		"    }",
		"    int kth(int k) { return kth(root, k); }",
		"",
		"    // Count elements <= val",
		"    int order_of_key(int val) {",
		"        Node *l, *r;",
		"        split(root, val, l, r);",
		"        int res = sz(l);",
		"        merge(root, l, r);",
		"        return res;",
		"    }",
		"};"
	],
	"description": "Treap (Cartesian Tree) with Split, Merge, Insert, Erase, Union"
    },

    "power":
    {
    "prefix" : "power",
        "body" : [
                "int modPow(int base, int exp) {",
                "\tint res = 1;",
                "\twhile (exp > 0) {",
                "\t    if (exp & 1ll) res = (res * base) % MOD;",
                "\t    base = (base * base) % MOD;",
                "\t    exp >>= 1ll;",
                "\t}",
                "\treturn res;",
                "}"
            ],
            "description": "to produce snippet for power code compatible with mod"
    },
    "sqrt":{
        "prefix": "sqrt",
        "body": [
            "int sqrt_(int n){",
            "  int l = 0, h = 5000000001;",
            "  while(l <= h){",
            "    int mid =(l+h)>>1;",
            "    if(mid*mid > n){",
            "      h = mid - 1;",
            "    }else{",
            "      l = mid + 1;",
            "    }",
            "  }",
            "  return l-1;",
            "}"
        ]
    },
    "combinations":{
        "prefix": "combinations",
        "body": [
            "const int MAXN = 2e5 + 5;",
            "static int fact[MAXN+1], invfact[MAXN+1];",
            "int modPow(int base, int exp) {",
            "  int res = 1;",
            "  while (exp > 0) {",
            "      if (exp & 1ll) res = (res * base) % MOD;",
            "      base = (base * base) % MOD;",
            "      exp >>= 1ll;",
            "  }",
            "  return res;",
            "}",
            "",
            "int modinv(int a) {",
            "    return modPow(a, MOD - 2);",
            "}",
            "static bool flag = false;",
            "void precompute_combinations(){",
            "    fact[0] = invfact[0] = 1;",
            "    for(int i = 1; i <= MAXN; i++) {",
            "        fact[i] = fact[i - 1] * i % MOD;",
            "      }",
            "    ",
            "    invfact[MAXN] = modinv(fact[MAXN]);",
            "    for(int i = MAXN-1; i >= 0;i--){",
            "      invfact[i] = invfact[i+1]*(i+1) % MOD;",
            "    }",
            "}",
            "int C(int n, int r) {",
            "    if(!flag){precompute_combinations();flag = true;}",
            "    if(r < 0 || r > n) return 0;",
            "    return fact[n] * invfact[r] % MOD * invfact[n - r] % MOD;",
            "}",
            "// _________________ dont forget to run precompute_combinations() !______________"
        ]
    },
    "vector input":{
        "prefix": "vfi",
        "body": [
            "for(auto& x : a)cin>> x;"
        ],
        "description": "To produce the snippet for vector fast input"

    },

    "input":
    {
    "prefix" : "ci",
        "body" : [
                "cin >> ",
            ],
            "description": "to produce the snippet for cin >> "
    },
    "output":
    {
    "prefix" : "co",
        "body" : [
            "cout << ",
            ],
            "description": "to produce the snippet for cout << "
    },

    "for loop":
    {
    "prefix" : "fi",
        "body" : [
            "for(int i = 0; i< n; i++)",
            "{",
            "\t",
            "}",
            ],
            "description": "to produce the snippet for for loop"
    },

    "for loop with variable j":
    {
    "prefix" : "fj",
        "body" : [
            "for(int j = 0; j< n; j++)",
            "{",
            "\t",
            "}",
            ],
            "description": "to produce the snippet for for loop"
    },

    "input loop":
    {
    "prefix" : "li",
        "body" : [
            "for(int i = 0; i< n; i++)",
            "{",
            "\tcin >> arr[i];",
            "}",
            ],
            "description": "to produce the snippet for input loop"
    },
    "display loop":
    {
    "prefix" : "di",
        "body" : [
            "for(int i = 0; i< n; i++)",
            "{",
            "\tcout << arr[i] << \", \"; ",
            "}",
            "cout << '\\n';",
            ],
            "description": "to produce the snippet for display loop"
    },
    "for each loop":
    {
    "prefix" : "efi",
        "body" : [
            "for(const auto& x : arr)",
            "{",
            "\t",
            "}",
            ],
            "description": "to produce the snippet for for-each loop"
    },
    "ordered set":{
        "prefix": "oset",
        "body": [
            "#undef int",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "template<typename T>",
            "using oset = tree<",
            "    T,",
            "    null_type,",
            "    less<T>,",
            "    rb_tree_tag,",
            "    tree_order_statistics_node_update>;",
            "#define int long long"
        ],
        "description": "ordered set snippet"
    },
    "ordered multiset":{
        "prefix": "mset",
        "body": [
            "#undef int",
            "template<typename T>",
            "using mset = tree<",
            "   pair<T, int>, // use index or timestamp to break ties",
            "   null_type,",
            "   less<pair<T, int>>,",
            "   rb_tree_tag,",
            "   tree_order_statistics_node_update>;",
            "#define int long long"
        ],
        "description": "ordered multiset"
    },
    "ordered map":{
        "prefix": "omap",
        "body": [
            "#undef int",
            "template<typename Key, typename Value>",
            "using omap = tree<",
            "    Key,",
            "    Value,",
            "    less<Key>,",
            "    rb_tree_tag,",
            "    tree_order_statistics_node_update>;",
            "#define int long long"
        ],
        "description": "ordered map"
    },
    "unordered set":{
        "prefix": "uset",
        "body": [
            "#undef int",
            " #include <ext/pb_ds/assoc_container.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "template<typename T>",
            "using uset = gp_hash_table<T, null_type>;",
            "#define int long long"
        ],
        "description": "unordered set"
    },
    "unordered map":{
        "prefix": "umap",
        "body": [
            "#undef int",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "template<typename Key, typename Value>",
            "using umap = gp_hash_table<Key, Value>;",
            "#define int long long"
        ],
        "description": "unordered map"
    },


    "sqrt decomposition min":{
       "prefix": "sqrt d min",
        "body": [
          "class Sqrt_decomposition{",
          " private:",
          "int n;",
          "vector<int> a; // actual array",
          "vector<int> block; // block representation of the array, stores minimum in each block",
          "int block_size; // size of block",
          "int s; // no . of blocks",
          "public:",
          "void init(const vector<int>& arr){",
          "  this->n = arr.size();",
          "  this->a= arr;",
          "  this->block_size = max(1ll,(int)sqrt((int)a.size()));",
          "  this->s = (n+block_size-1)/block_size;",
          "  build();",
          "}",
          "void build(){",
          "  block.resize(s, 1e9);",
          "  for(int i = 0; i < n; i++){",
          "    int idx= i/block_size;",
          "    block[idx] = min(block[idx], a[i]);",
          "  }",
          "}",
        "",
          "int query(int l, int r){",
          "  int ans = 1e9;",
          "  int left_block = l / block_size;",
          "  int right_block = r / block_size;",
        "",
          "  // l,r within a single block",
          "  if (left_block == right_block) {",
          "      for (int i = l; i <= r; ++i) ans = min(ans, a[i]);",
          "      return ans;",
          "  }",
        "",
          "  // left partial block",
          "  int left_end = min(n - 1, (left_block + 1) * block_size - 1);",
          "  for (int i = l; i <= left_end; ++i) ans = min(ans, a[i]);",
        "",
          "  // full blocks",
          "  for (int b = left_block + 1; b <= right_block - 1; ++b) {",
          "      ans = min(ans, block[b]);",
          "  }",
        "",
          "  // right partial block",
          "  int right_start = right_block * block_size;",
          "  for (int i = right_start; i <= r; ++i) ans = min(ans, a[i]);",
        "",
          "  return ans;",
          "}",
          "void update(int i, int new_val){",
          "  a[i]  = new_val;",
          "  int blk_id = i/block_size;",
          "  block[blk_id] = 1e9;",
          "  for(int idx = blk_id*block_size; idx < min(n, (blk_id+1)*block_size) ; idx++){",
          "    block[blk_id] = min(a[idx], block[blk_id]);",
          "  }",
          "}",
        "};"
            ]
    },

    "Modular Integer data type":{
        "prefix": "Mint",
        "body": [
            " ",
            "const int mod = 998244353;",
            "struct mint{",
            "    int x;",
            " ",
            "    mint (){ x = 0;}",
            "    mint (int32_t xx){ x = xx % mod; if (x < 0) x += mod;}",
            "    mint (long long xx){ x = xx % mod; if (x < 0) x += mod;}",
            " ",
            "    int val(){",
            "        return x;",
            "    }",
            "    mint &operator++(){",
            "        x++;",
            "        if (x == mod) x = 0;",
            "        return *this;",
            "    }",
            "    mint &operator--(){",
            "        if (x == 0) x = mod;",
            "        x--;",
            "        return *this;",
            "    }",
            "    mint operator++(int32_t){",
            "        mint result = *this;",
            "        ++*this;",
            "        return result;",
            "    }",
            "    ",
            "    mint operator--(int32_t){",
            "        mint result = *this;",
            "        --*this;",
            "        return result;",
            "    }",
            "    mint& operator+=(const mint &b){",
            "        x += b.x;",
            "        if (x >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "    mint& operator-=(const mint &b){",
            "        x -= b.x;",
            "        if (x < 0) x += mod;",
            "        return *this;",
            "    }",
            "    mint& operator*=(const mint &b){",
            "        long long z = x;",
            "        z *= b.x;",
            "        z %= mod;",
            "        x = (int)z;",
            "        return *this;",
            "    }",
            "    mint operator+() const {",
            "        return *this;",
            "    }",
            "    mint operator-() const {",
            "        return mint() - *this;",
            "    }",
            "    mint operator/=(const mint &b){",
            "        return *this = *this * b.inv();",
            "    }",
            "    mint power(long long n) const {",
            "        mint ok = *this, r = 1;",
            "        while (n){",
            "            if (n & 1){",
            "                r *= ok;",
            "            }",
            "            ok *= ok;",
            "            n >>= 1;",
            "        }",
            "        return r;",
            "    }",
            "    mint inv() const {",
            "        return power(mod - 2);",
            "    }",
            "    friend mint operator+(const mint& a, const mint& b){ return mint(a) += b;}",
            "    friend mint operator-(const mint& a, const mint& b){ return mint(a) -= b;}",
            "    friend mint operator*(const mint& a, const mint& b){ return mint(a) *= b;}",
            "    friend mint operator/(const mint& a, const mint& b){ return mint(a) /= b;}",
            "    friend bool operator==(const mint& a, const mint& b){ return a.x == b.x;}",
            "    friend bool operator!=(const mint& a, const mint& b){ return a.x != b.x;}",
            "    mint power(mint a, long long n){",
            "        return a.power(n);",
            "    }",
            "    friend ostream &operator<<(ostream &os, const mint &m) {",
            "        os << m.x;",
            "        return os;",
            "    }",
            "    explicit operator bool() const {",
            "        return x != 0;",
            "    }",
            "};",
            "// Remember to check MOD"
        ],
        "description": "The modular integer data type"
    },
   "Debug Template": {
  "prefix": "debugtemplate",
  "body": [
    "template <typename A, typename B>",
    "string to_string(pair<A, B> p);",
    "",
    "template <typename A, typename B, typename C>",
    "string to_string(tuple<A, B, C> p);",
    "",
    "template <typename A, typename B, typename C, typename D>",
    "string to_string(tuple<A, B, C, D> p);",
    "",
    "string to_string(const string& s) {",
    "  return '\"' + s + '\"';",
    "}",
    "",
    "string to_string(const char* s) {",
    "  return to_string((string) s);",
    "}",
    "",
    "string to_string(bool b) {",
    "  return (b ? \"true\" : \"false\");",
    "}",
    "",
    "string to_string(vector<bool> v) {",
    "  bool first = true;",
    "  string res = \"{\";",
    "  for (int i = 0; i < static_cast<int>(v.size()); i++) {",
    "    if (!first) {",
    "      res += \", \";",
    "    }",
    "    first = false;",
    "    res += to_string(v[i]);",
    "  }",
    "  res += \"}\";",
    "  return res;",
    "}",
    "",
    "template <size_t N>",
    "string to_string(bitset<N> v) {",
    "  string res = \"\";",
    "  for (size_t i = 0; i < N; i++) {",
    "    res += static_cast<char>('0' + v[i]);",
    "  }",
    "  return res;",
    "}",
    "",
    "template <typename A>",
    "string to_string(A v) {",
    "  bool first = true;",
    "  string res = \"{\";",
    "  for (const auto &x : v) {",
    "    if (!first) {",
    "      res += \", \";",
    "    }",
    "    first = false;",
    "    res += to_string(x);",
    "  }",
    "  res += \"}\";",
    "  return res;",
    "}",
    "",
    "template <typename A, typename B>",
    "string to_string(pair<A, B> p) {",
    "  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
    "}",
    "",
    "template <typename A, typename B, typename C>",
    "string to_string(tuple<A, B, C> p) {",
    "  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";",
    "}",
    "",
    "template <typename A, typename B, typename C, typename D>",
    "string to_string(tuple<A, B, C, D> p) {",
    "  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";",
    "}",
    "",
    "void debug_out() { cerr << endl; }",
    "",
    "template <typename Head, typename... Tail>",
    "void debug_out(Head H, Tail... T) {",
    "  cerr << \" \" << to_string(H);",
    "  debug_out(T...);",
    "}",
    "",
    "#ifdef ONLINE_JUDGE",
    "#define debug(...) 42",
    "#else",
    "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
    "#endif"
  ],
  "description": "C++ debug template with to_string and debug macros"
}

}
